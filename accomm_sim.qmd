---
title: "Sleeping Around"
format: html
editor: visual
---

# Introduction

```{r setup}
library(tidyverse)
library(janitor)
library(sf)
library(stringi)
set.seed(1225)

# load data
garda_stations <- read_csv("data/garda_stations.csv")
accomm_names <- read_csv("data/provider_names.csv") |> 
  # generate a unique id for each accommodation that is not just based on row number
  mutate(accomm_id = paste0("ACCOM_", str_pad(row_number(), width = 4, pad = "0")))
```

## Client List

Generate a client list of 21000 clients, each assigned to one of the 450 accommodation locations.

```{r setup-locations}

accomm_locations <- garda_stations |> 
  select(ADDRESS, LONGITUDE, LATITUDE) |>
  bind_cols(accomm_names)

#create a list of 21000 clients, with the following information; ID, Name, Family Unit ID, Family_Unit_Head_Status, Accommodation_Name
client_list <- read_csv("data/clients_21000.csv") |> 
  clean_names()

# randomly assign accommodation by family unit
client_list |> 
  distinct(family_unit_id) |> 
  mutate(accommodation_name = sample(accomm_locations$accomm_name, n(), replace = TRUE)) -> accomm_assignment

# join accommodation names to client list
client_list |> 
  left_join(accomm_assignment, by = c("family_unit_id" = "family_unit_id")) -> client_list


client_list |>
  group_by(family_unit_id) |> 
  mutate(family_member_count = n()) |> 
  ungroup() -> client_full
```

## Generate Sample Datapoints for the PlaceKeeper App

Each of the 21,000 clients who have Family_Unit_Head_Status as true, should have a row for every day in January 2026, listing their dependents and the accommodation they are staying at.

```{r generate-datapoints}
# create all dates for January 2026
january_dates <- seq(as.Date("2026-01-01"), as.Date("2026-01-31"), by = "day")

client_full |> 
  filter(family_unit_head_status == "Yes") |>
  # create a row for all of these for each date in January
  crossing(date = january_dates) |> 
  mutate(time = sample(5:12, n(), replace = TRUE),
         minutes = sample(0:59, n(), replace = TRUE),
         timestamp = as.POSIXct(paste(date, sprintf("%02d:%02d:00", time, minutes)), format="%Y-%m-%d %H:%M:%S")) |> 
  select(-c(date, time, minutes)) -> client_timestamps

client_timestamps |> 
  left_join(accomm_locations, by = c("accommodation_name" = "accomm_name")) |>
  st_as_sf(coords = c("LONGITUDE", "LATITUDE"), crs = 4326) |> 
  st_transform(2157) |> 
  # create an x and y column for the geometry
  mutate(x = st_coordinates(geometry)[,1],
         y = st_coordinates(geometry)[,2]) |> 
  st_set_geometry(NULL) |> 
  # add a random jitter of a radius of between 10 and 200m to the x and y coordinates to simulate real sensor data, with a log linear distance from the origin point
  rowwise() |>
  mutate(
    angle = runif(1, 0, 2 * pi),
    radius = exp(runif(1, log(10), log(200))),
    x = x + radius * cos(angle),
    y = y + radius * sin(angle)
  ) |>
  ungroup() -> client_timestamps_p1

n_days <- client_timestamps_p1 |> 
  distinct(as.Date(timestamp)) |> 
  nrow()

clients <- client_timestamps_p1 %>%
  distinct(id) %>%
  mutate(
    group = sample(
      x = c("daily","miss_1","miss_2_5","miss_6_14","miss_15_25", "miss_26_30", "miss_all"),
      size = n(),
      replace = TRUE,
      prob = c(0.05, 0.05, 0.70, 0.15, 0.025, 0.02, 0.005)
    ),
    miss_days = case_when(
      group == "daily"      ~ 0,
      group == "miss_1"     ~ 1,
      group == "miss_2_5"   ~ sample(2:5,  n(), replace = TRUE),
      group == "miss_6_14"  ~ sample(6:14, n(), replace = TRUE),
      group == "miss_15_25" ~ sample(15:25,n(), replace = TRUE),
      group == "miss_26_30" ~ sample(26:30,n(), replace = TRUE),
      group == "miss_all" ~ 31
    ),
    p_respond = pmax(0, 1 - (miss_days / n_days))
  )

set.seed(123)

client_timestamps_p1 %>%
  group_by(id) %>%
  nest() |> 
  left_join(clients, by = "id") |> 
  mutate(data = map2(data, p_respond, ~ .x %>% filter(runif(n()) < .y))) |> 
  select(-group, -miss_days, -p_respond) |> 
  unnest(cols = c(data)) -> real_responses


real_responses |> 
  select(primary_id = id, 
         accommodation_name,
         dependent_count = family_member_count,
         CreationDate = timestamp,
         EditDate = timestamp,
         x,
         y) |> 
  mutate(Creator = "",
         Editor = "") |> 
  # convert back to sf object
  st_as_sf(coords = c("x", "y"), crs = 2157) |> 
  st_transform(4326) -> client_timestamps_sf


# write to file
st_write(client_timestamps_sf, "data/client_timestamps_january_2026.geojson", delete_dsn = TRUE)
```

# Build the Provider Weekly Returns

```{r provider-returns}
# build the features that represent the provider locations
accomm_locations |> 
  st_as_sf(coords = c("LONGITUDE", "LATITUDE"), crs = 4326) |> 
  # write to an esri geodatabase
  st_write(driver = "OpenFileGDB",
           "C:/R Projects/Innovation_Project/InnKeeper/InnKeeper.gdb/", 
           layer = "provider_locations", 
           delete_layer = TRUE)


client_timestamps_sf |> 
  st_set_geometry(NULL) |> 
  rename(
    accomm_name = accommodation_name,
    date = CreationDate) |> 
  select(primary_id, accomm_name, date, dependent_count) -> df_client

dates <- seq(min(df_client$date), max(df_client$date), by = "day")

p_proxy_absent <- 0.20        # chance an absent day is still reported as present (proxy sign-in)
p_false_absent <- 0.005       # chance a true present day is mistakenly reported absent (admin error)
weekly_overstatement_rate <- 0.02  # small systematic weekly uplift (2%)

set.seed(123)

# Ensure date is Date
df_client <- df_client %>%
  mutate(date = trunc.Date(date, "days"))

# Define the month window explicitly (optional but recommended)
# e.g. first to last day in df_client
dates <- seq(min(df_client$date), max(df_client$date), by = "day")

# 1) Create a "roster" of each primary_id's accommodation (most frequent observed)
df_client %>%
  ungroup() |> 
  summarise(.by = c(primary_id, accomm_name), 
            n = n(),
            household_size = mean(dependent_count + 1)) %>%
  arrange(primary_id, desc(n)) %>%
  ungroup() %>%
  select(primary_id, accomm_name, household_size) -> roster

# 2) Build full daily grid (all clients for all days)
panel <- roster %>%
  crossing(date = dates)

# 3) Join true presence from client data
# If a row exists => true persons present = 1 + dependent_count
panel %>%
  left_join(df_client %>% select(primary_id, date, dependent_count),
            by = c("primary_id","date")) %>%
  mutate(
    true_present = !is.na(dependent_count),
    true_persons = ifelse(true_present, 1 + dependent_count, 0)
  ) -> truth_daily

# Simulate provider daily perception
truth_daily %>%
  mutate(
    p_provider_present = case_when(
      true_present  ~ 1 - p_false_absent,
      !true_present ~ p_proxy_absent),
    provider_present = runif(n()) < p_provider_present,
    provider_persons = ifelse(provider_present, household_size, 0),
    week_start = floor_date(date, "week", week_start = 1)
  ) -> provider_daily 

# Aggregate to weekly provider reports
provider_daily %>%
  group_by(accomm_name, week_start) %>%
  summarise(
    provider_beddays_raw = sum(provider_persons),
    provider_households_raw = n_distinct(primary_id[provider_persons > 0]),
    .groups = "drop"
  ) -> provider_weekly_raw 

provider_weekly <- provider_weekly_raw %>%
  mutate(
    understates_this_week = runif(n()) < 0.15,
    overstates_this_week = runif(n()) > 0.8,

    discrepency_rate = case_when(
      understates_this_week ~ rbeta(n(), shape1 = 6, shape2 = 20) * -.15,
      overstates_this_week ~ rbeta(n(), shape1 = 6, shape2 = 20) * 0.2,  
      TRUE ~ 0),
    provider_beddays_reported =
      provider_beddays_raw +
      round(provider_beddays_raw * discrepency_rate)
  ) |> 
  left_join(accomm_locations |> select(accomm_name, accomm_id)) |>
  relocate(accomm_id, .before = everything())

mean(provider_weekly$overstates_this_week > 0)
mean(provider_weekly$understates_this_week > 0)

sum(provider_weekly$provider_beddays_reported) /
sum(provider_weekly$provider_beddays_raw) - 1

```

